**Java-垃圾收集器**

[TOC]

# 垃圾收集器

垃圾收集器（Garbage Collection），通常被称作GC。GC主要做了两个工作：

* 内存的划分和分配
* 对垃圾进行回收，被引用的对象是存活的对象，而不被引用的对象是死亡的对象也就是垃圾。

# Java引用

* **强引用**：如果一个对象具有强引用（new 一个对象时就是创建一个具有强引用的对象），GG就绝不会回收它。Java虚拟机宁愿抛出 OutOfMemoryError 异常，使程序异常终止也不会回收强引用以解决内存不足的问题。
* **软引用**：如果一个对象只具有软引用，当内存不够时会回收这个对象的内存，回收后如果还是没有足够的内存，就会抛出 OutOfMemoryError 异常。Java提供了 SoftReference 类来实现软引用。
* **弱引用**：GC 一旦发现了只具有弱引用的对象，不管当前内存是否足够，都会回收它的内存。Java 提供了 WeakRefrence 类来实现弱引用。
* **虚引用**：虚引用并不决定对象的生命周期，如果一个对象仅持有虚引用，这就和没有任何引用一样，在任何时候都有可能被垃圾收集器回收。一个只具有虚引用的对象，被垃圾收集器回收时会收到一个系统通知，这也是虚引用的的主要作用。Java 提供了 PhantomReference 类来实现虚引用。

# 垃圾标记算法

GC要进行垃圾回收，必须要先对垃圾进行标记，如何进行标记呢，目前主要有两种标记算法，分别是**引用计数算法和根搜索算法**。

## 引用计数法

>基本思想就是每个对象都有一个引用计数器，当对象在某处被引用时，它的引用计数器就加1，引用失效时就减1。当引用计数器中的值为0时，则该对象就不能被使用变成了垃圾。

目前主流的 Java 虚拟机没有选择引用计数算法来标记垃圾，主要原因是**引用计数算法没有解决对象之间相互循环引用的问题。**

**STW** 就是 Stop the World 机制（Full GC 时触发），意思是说在执行垃圾收集算法时，只有 GC 线程在运行，其他的线程则会全部暂停，等待 GC 线程执行完毕后才能再次运行。

如果你使用Android Studio，就在Edit Configurations中的VM options加入如下语句来输出详细的GC日志：

```
-XX:+PrintGCDetails
```

## 根搜索算法

>基本思想就是选择一些对象作为 GC Roots，并组成根对象集合，然后将这些 GC Roots 的对象作为起始点，向下进行搜索，如果目标对象到 GC Roots 是连接着的，则称该目标对象是可达的，如果目标对象不可达，则说明目标对象是可以被回收的对象。

![](http://upload-images.jianshu.io/upload_images/1417629-0c286c3caefd7b16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

如图所示，Obj5和Obj6虽然相互引用，但是因为他们到 GC Roots 是不可达的，所以仍会被认为是可回收的对象，**这样根搜索算法就解决了引用计算对象无法解决的问题：已经死亡的对象因为相互引用而不能被回收**。

在 Java 中，可以作为 GC Roots 对象的主要有以下几种：

* Java 栈中引用的对象
* 本地方法栈中 JNI 引用的对象
* 方法区中运行时常量池引用的对象
* 方法区中静态属性引用的对象
* 运行中的线程
* 由引导类加载器加载的对象
* GC 控制的对象

# Java对象在虚拟机的生命周期

当 Java 对象被类加载器加载到虚拟机后，Java 对象在虚拟机中有7个阶段。

* **1.创建阶段（Created）**

创建阶段的步骤为：

```
1. 为对象分配存储空间
2. 构造对象
3. 从超类到子类对 Static 成员进行初始化
4. 递归调用超类的构造方法
5. 调用子类的构造方法
```

* **2.应用阶段（In Use）**

当对象被创建，并**分配给变量赋值**，Java 对象就进入的应用阶段，这一阶段的对象至少要具有一个强引用，或者显式的使用软引用、弱引用或虚引用。

* **3.不可见阶段（Invisible）**

**程序中找不到对象的任何强引用**，比如程序的执行已经超出了该对象的作用域。在不可见阶段，对象仍肯被特殊的强引用 GC Roots 持有着，比如对象被本地方法栈中 JNI 引用或是被运行中的线程引用。

* **4.不可达阶段（Unreachable）**

程序中找不到对象的任何强引用，并且垃圾收集器发现对象不可达。

* **5.收集阶段（Collected）**

垃圾收集器发现对象不可达，并且垃圾收集器已经准备好对该对象的内存空间重新进行分配。这个时候如果该对象重写了 finalize 方法，则会调用该方法。

* **6.终结阶段（Finalized）**

当对象执行完 finalize 方法后仍然处于不可达状态，或者对象没有重写 finalize 方法时，则该对象进入终结阶段，并等待 GC 回收该对象空间。

* **7.对象空间重新分配阶段（Deallocated）**

当垃圾收集器对对象的内存空间进行回收或者再分配时，这个对象就会彻底消失。


Q&A：被标记为不可达的对象会立即被垃圾回收器回收吗？

>不会。被标记为不可达的对象会进入收集阶段，这时会执行该对象重写的 finalize 方法，如果没有重写 finalize 方法或者 finalize 方法中没有重新与一个可达的对象进行关联时才会进入终结阶段，并最终被回收。

# 垃圾收集算法

## 标记-清除算法

标记-清除算法（Mark-Sweep）是一种基础垃圾收集算法，其过程分为两个过程：

* 标记阶段：标记出可以回收的对象
* 清除阶段：回收标记的对象所占用的内存空间

标记-清除算法的缺点：

* 标记和清除的效率不高
* 容易产生大量的不连续的内存碎片，碎片太多可能会导致后续没有足够的连续内存分配给较大的对象，从而提前触发一次新的垃圾收集动作。

## 复制算法

复制算法把内存空间分为两个相等的区域，每次只使用其中一个区域。垃圾收集时遍历当前区域，把存活的对象复制到另一个区域中，最后将当前使用的的区域的可回收对象进行回收。

复制算法每次都对整个半区进行内存回收，不需要考虑标记-清楚算法中内存碎片的问题，代价就是使用内存为原来的一半。复制算法的效率跟存活对象的数量有很大的关系，如果存活对象很少，复制算法的效率就很高。

由于绝大多数对象的生命周期很短，并且这些生命周期很短的对象都存于新生代中（新生代的对象存活率较低），所以复制算法被广泛应用于新生代中。

## 标记-压缩算法

标记-压缩算法（Mark-Compact）算法，与标记-清除算法不同的是，在标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边。

标记-压缩算法解决了标记-清除算法效率低和容易产生大量内存碎片的问题，它被广泛的应用于老年代中（老年代的对象存活率会较高）。

## 分代收集算法

### Java堆区的空间划分

Java堆区基于分代的概念可分为：

* 新生代（Young Generation）
    * Eden空间：此空间中的大多对象生命周期很短
    * From Survior空间
    * To Survior空间
* 老年代（Tenured Generation）

### 分代收集

根据Java堆区的空间划分，垃圾收集的类型分为两种，它们分别是：

* Minor Collection：新生代垃圾收集
* Full Collection：对新生代、老年代进行收集，它的收集频率较低，耗时较长。

# 参考文章

[Java虚拟机（三）垃圾标记算法与Java对象的生命周期](http://liuwangshu.cn/java/jvm/3-garbage-mark.html)

[Java虚拟机（四）垃圾收集算法](http://liuwangshu.cn/java/jvm/4-garbage-collection.html)

