---
title: Android EventBus3.0源码解析
date: 2016-04-18 23:05:06
tags: 源码分析
categories: Android
---

前面已经介绍了EventBus3.0开源库的详细使用，下面我们开始进入其源代码的学习，先看看EventBus3.0与2.x版本之间的区别。

>项目地址[https://github.com/greenrobot/EventBus](https://github.com/greenrobot/EventBus)
>EventBus版本是3.0

# EventBus 3.0与2.x的区别

## 注册订阅者

```Java
//3.0版本的注册
EventBus.getDefault().register(this);

//2.x版本的注册
EventBus.getDefault().register(this);
EventBus.getDefault().register(this, 100);
EventBus.getDefault().registerSticky(this, 100);
EventBus.getDefault().registerSticky(this);
```
2.x版本中有四种注册方法，区分了普通注册和粘性事件注册，并且在注册时可以选择接受事件的优先级；

3.0版本中将粘性事件以及订阅事件的优先级用注解的方式实现，所以3.0版本中的注册就变得只有一个register()方法注册。

## 事件订阅方法

```Java
//3.0版本
@Subscribe(threadMode = ThreadMode.BACKGROUND, sticky = true, priority = 100)
public void test(String str) {

}

//2.x版本
public void onEvent(String str) {

}
public void onEventMainThread(String str) {

}
public void onEventBackgroundThread(String str) {

}
```
2.x版本中只有通过onEvent开头的方法会被注册，而且响应事件方法触发的线程通过onEventMainThread或onEventBackgroundThread这些方法名区分；

3.0版本中，通过@Subscribe注解来确定运行的线程threadMode，是否接收粘性事件sticky以及事件优先级priority，而且方法名不再需要使用onEvent开头，所以3.0提高了简单性和灵活性。

## 发送事件

发送事件和发送粘性事件在2.x和3.0版本中是相同的。

```Java
EventBus.getDefault().post("str");
EventBus.getDefault().postSticky("str");
```
## 解除注册

2.x和3.0版本的解除注册的方法也是相同的。

```Java
EventBus.getDefault().unregister(this);
```


# 类关系图

类图引用自[CodeKK的EventBus源代码分析](http://a.codekk.com/detail/Android/Trinea/EventBus%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90)

![类图](http://7xs7a3.com1.z0.glb.clouddn.com/eventbus-%E7%B1%BB%E5%9B%BE.png)

从类图可以看出，上部分主要是订阅相关信息，中间是EventBus，下面部分是发布者发布事件后的调用。下面开始进入源码分析:

# 源码分析

通过EventBus的使用流程来分析它的调用流程及实现原理。

## 创建EventBus

一般都是通过`EventBus.getDefault()`静态方法获取到EventBus对象，先来看看getDefault()方法的实现

```Java
public static EventBus getDefault() {
	if (defaultInstance == null) {
		synchronized (EventBus.class) {
			if (defaultInstance == null) {
				defaultInstance = new EventBus();
			}
		}
	}
	return defaultInstance;
}
```

这里使用**单例模式**获取EventBus对象，目的是保证getDefault方法得到的是同一个EventBus对象。第一次创建实例，会调用EventBus的构造方法

```Java
public EventBus() {
	this(DEFAULT_BUILDER);
}

//key:订阅的事件 value：订阅这个事件的所有订阅者集合
private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;

//key:订阅者对象， value：这个订阅者订阅的事件集合
private final Map<Object, List<Class<?>>> typesBySubscriber;

//粘性事件 key：粘性事件的class对象， value：事件对象
private final Map<Class<?>, Object> stickyEvents;

EventBus(EventBusBuilder builder) {
	subscriptionsByEventType = new HashMap<>();
	typesBySubscriber = new HashMap<>();
	stickyEvents = new ConcurrentHashMap<>();
	
	//事件主线程处理
	mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);
	//事件Background处理
	backgroundPoster = new BackgroundPoster(this);
	//事件异步线程处理
	asyncPoster = new AsyncPoster(this);
	indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0;
	//订阅者想要方法信息存储和查找
	subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,
			builder.strictMethodVerification, builder.ignoreGeneratedIndex);
	logSubscriberExceptions = builder.logSubscriberExceptions;
	logNoSubscriberMessages = builder.logNoSubscriberMessages;
	sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;
	sendNoSubscriberEvent = builder.sendNoSubscriberEvent;
	throwSubscriberException = builder.throwSubscriberException;
	//是否支持事件继承
	eventInheritance = builder.eventInheritance;
	executorService = builder.executorService;
}
```
## 注册事件过程

### register()方法的实现

```Java
public void register(Object subscriber) {
	//首先获取订阅者的class对象
	Class<`?> subscriberClass = subscriber.getClass();
	//1 获取订阅者订阅的事件集合
	List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
	synchronized (this) {
		for (SubscriberMethod subscriberMethod : subscriberMethods) {
			//2 订阅
			subscribe(subscriber, subscriberMethod);
		}
	}
}

public SubscriberMethod(Method method, Class<?> eventType, ThreadMode threadMode, int priority, boolean sticky) {
	this.method = method; //事件处理方法的Method对象
	this.threadMode = threadMode; //线程的ThreadMode
	this.eventType = eventType; //订阅的事件类型
	this.priority = priority; //事件优先级
	this.sticky = sticky; //是否接收粘性事件
}
```
通过subscriberMethodFinder.findSubscriberMethods(subscriberClass)方法可以返回一个SubscriberMethod对象的集合，下面来看看findSubscriberMethods()方法的实现

### SubscriberMethodFinder的实现

SubscriberMethodFinder类就是用来查找和缓存订阅者响应方法的信息的类。那么怎么能获得订阅者响应函数的相关信息呢？在3.0版本中,EventBus提供了一个EventBusAnnotationProcessor注解处理器来在编译期通过读取@Subscribe注解并解析，然后生成java类来保存所有订阅者关于订阅的信息，这样就比在运行时使用反射来获得这些订阅者的信息速度要快。我们可以参考EventBus项目里的EventBusPerformance这个例子，编译后我们可以在build文件夹里找到这个类，MyEventBusIndex类，当然类名是可以自定义的，下面看一下生成的MyEventBusIndex类的组成：

```Java
/**
 * This class is generated by EventBus, do not edit.
 */
public class MyEventBusIndex implements SubscriberInfoIndex {
    private static final Map<Class<?>, SubscriberInfo> SUBSCRIBER_INDEX;

    static {
        SUBSCRIBER_INDEX = new HashMap<Class<?>, SubscriberInfo>();

        putIndex(new SimpleSubscriberInfo(org.greenrobot.eventbusperf.testsubject.PerfTestEventBus.SubscriberClassEventBusAsync.class,
                true, new SubscriberMethodInfo[]{
                new SubscriberMethodInfo("onEventAsync", TestEvent.class, ThreadMode.ASYNC),
        }));

        putIndex(new SimpleSubscriberInfo(TestRunnerActivity.class, true, new SubscriberMethodInfo[]{
                new SubscriberMethodInfo("onEventMainThread", TestFinishedEvent.class, ThreadMode.MAIN),
        }));
    }

    private static void putIndex(SubscriberInfo info) {
        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);
    }

    @Override
    public SubscriberInfo getSubscriberInfo(Class<?> subscriberClass) {
        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);
        if (info != null) {
            return info;
        } else {
            return null;
        }
    }
}
```
可以看出是使用一个静态HashMap即：SUBSCRIBER_INDEX来保存订阅类的信息，其中包括了订阅类的Class对象，是否需要检查父类，以及订阅方法的信息SubscriberMethodInfo的数组，SubscriberMethodInfo中又保存了订阅方法的方法名、订阅的事件类型、触发线程，是否接收sticky事件以及优先级priority。这其中就保存了register()的所有需要的信息，如果再配置EventBus的时候通过EventBuilder配置：`eventBus=EventBus.builder().addIndex(new MyEventBusIndex()).build()`；来将编译生成的MyEventBusIndex配置进去，这样能在SubscriberMethodFinder类中直接查找出订阅类的信息，就不需要再利用注解判断了，这种方法是作为EventBus的可选配置存在的。

SubscriberMethodFinder同样提供了通过注解来获得订阅类信息的方法，下面来看看findSubscriberMethods()到底是如何实现的：

```Java
List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {

	//先从Method_CACHE取看是否有缓存，key：保存订阅类的类名，value:保存类中订阅的方法名
	List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
	if (subscriberMethods != null) {
		return subscriberMethods;
	}
	
	//是否忽略注解器生成的MyEventIndex类，默认false
	if (ignoreGeneratedIndex) {
		//利用反射来读取订阅类中的订阅方法
		subscriberMethods = findUsingReflection(subscriberClass);
	} else {
		//从注解器生成的MyEventBusIndex类中获得订阅类的订阅方法
		subscriberMethods = findUsingInfo(subscriberClass);
	}
	if (subscriberMethods.isEmpty()) {
		throw new EventBusException("Subscriber " + subscriberClass
				+ " and its super classes have no public methods with the @Subscribe annotation");
	} else {
		//保存到缓存中
		METHOD_CACHE.put(subscriberClass, subscriberMethods);
		return subscriberMethods;
	}
}
```
findUsingInfo()方法就是通过查找MyEventBusIndex类中的信息来转换成List<SubscriberMethod>从而获得订阅类的相关订阅方法的信息集合。

下面来看看findUsingReflection()的实现过程

```Java
private List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {
	//FindState用来做订阅方法的校验和保存
	FindState findState = prepareFindState();
	findState.initForSubscriber(subscriberClass);
	while (findState.clazz != null) {
		//通过反射获得订阅方法信息
		findUsingReflectionInSingleClass(findState);
		//查找父类的订阅方法
		findState.moveToSuperclass();
	}
	//获取findState中的SubscriberMethod(也就是订阅方法List)并返回
	return getMethodsAndRelease(findState);
}
```
这里通过FindState类来做订阅方法的校验和保存，并通过FIND_STATE_POOL静态数组来保存FindState对象，可以使FindState复用，避免重复创建过多的对象，最终是通过findUsingReflectionSingleClass()来具体获得相关订阅方法的信息的：

```Java
private void findUsingReflectionInSingleClass(FindState findState) {
	Method[] methods;
	//通过反射得到方法数组
	try {
		// This is faster than getMethods, especially when subscribers are fat classes like Activities
		methods = findState.clazz.getDeclaredMethods();
	} catch (Throwable th) {
		// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149
		methods = findState.clazz.getMethods();
		findState.skipSuperClasses = true;
	}
	//遍历Method
	for (Method method : methods) {
		int modifiers = method.getModifiers();
		if ((modifiers & Modifier.PUBLIC) != 0 && (modifiers & MODIFIERS_IGNORE) == 0) {
			Class<?>[] parameterTypes = method.getParameterTypes();
			//保证必须只有一个事件参数
			if (parameterTypes.length == 1) {
				//得到注解
				Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
				if (subscribeAnnotation != null) {
					Class<?> eventType = parameterTypes[0];
					//校验是否添加该方法
					if (findState.checkAdd(method, eventType)) {
						ThreadMode threadMode = subscribeAnnotation.threadMode();
						//实例化SubscriberMethod对象并添加
						findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode,
								subscribeAnnotation.priority(), subscribeAnnotation.sticky()));
					}
				}
			} else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
				String methodName = method.getDeclaringClass().getName() + "." + method.getName();
				throw new EventBusException("@Subscribe method " + methodName +
						"must have exactly 1 parameter but has " + parameterTypes.length);
			}
		} else if (strictMethodVerification && method.isAnnotationPresent(Subscribe.class)) {
			String methodName = method.getDeclaringClass().getName() + "." + method.getName();
			throw new EventBusException(methodName +
					" is a illegal @Subscribe method: must be public, non-static, and non-abstract");
		}
	}
}
```
上面代码运行后，订阅类的所有SubscriberMethod都已经被保存了，最后在通过getMethodsAndRelease方法返回List<SubscriberMethod>集合。

下面接着来看subscribe()是如何实现的

### subsribe()方法的实现

```Java
// 必须在同步代码块中调用
private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {

	//获取订阅事件的事件类型
	Class<?> eventType = subscriberMethod.eventType;
	//创建SubScription对象
	Subscription newSubscription = new Subscription(subscriber, subscriberMethod);
	//检查是否已经添加过该SubScription对象，添加过则抛出异常
	CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
	if (subscriptions == null) {
		subscriptions = new CopyOnWriteArrayList<>();
		subscriptionsByEventType.put(eventType, subscriptions);
	} else {
		if (subscriptions.contains(newSubscription)) {
			throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event "
					+ eventType);
		}
	}

	//根据优先级来添加SubScription对象
	int size = subscriptions.size();
	for (int i = 0; i <= size; i++) {
		if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {
			subscriptions.add(i, newSubscription);
			break;
		}
	}

	//将订阅者对象以及订阅的事件保存到typesBySubscriber中
	List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);
	if (subscribedEvents == null) {
		subscribedEvents = new ArrayList<>();
		typesBySubscriber.put(subscriber, subscribedEvents);
	}
	subscribedEvents.add(eventType);
	//如果接受sticky事件则立即分发sticky事件
	if (subscriberMethod.sticky) {
		//eventInheritance表示是否分发订阅了响应事件类及父类事件的方法
		if (eventInheritance) {
			// Existing sticky events of all subclasses of eventType have to be considered.
			// Note: Iterating over all events may be inefficient with lots of sticky events,
			// thus data structure should be changed to allow a more efficient lookup
			// (e.g. an additional map storing sub classes of super classes: Class -> List<Class>).
			Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();
			for (Map.Entry<Class<?>, Object> entry : entries) {
				Class<?> candidateEventType = entry.getKey();
				if (eventType.isAssignableFrom(candidateEventType)) {
					Object stickyEvent = entry.getValue();
					checkPostStickyEventToSubscription(newSubscription, stickyEvent);
				}
			}
		} else {
			Object stickyEvent = stickyEvents.get(eventType);
			checkPostStickyEventToSubscription(newSubscription, stickyEvent);
		}
	}
}
```

一下结合一张图来理解整个注册过程：

![注册过程](http://7xs7a3.com1.z0.glb.clouddn.com/eventbus-%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B.png)

## 事件分发过程

EventBus通过post方法来发送一个事件，首先看看post方法的实现过程

```Java
public void post(Object event) {
	//得到当前线程的Posting状态
	PostingThreadState postingState = currentPostingThreadState.get();
	//获取当前线程的事件队列
	List<Object> eventQueue = postingState.eventQueue;
	//加入事件到队列
	eventQueue.add(event);

	if (!postingState.isPosting) {
		postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();
		postingState.isPosting = true;
		if (postingState.canceled) {
			throw new EventBusException("Internal error. Abort state was not reset");
		}
		try {
			//发送知道队列为空
			while (!eventQueue.isEmpty()) {
				//发送单个事件
				postSingleEvent(eventQueue.remove(0), postingState);
			}
		} finally {
			postingState.isPosting = false;
			postingState.isMainThread = false;
		}
	}
}
```
首先是通过currentPostingThreadState.get()方法来得到当前线程PostingThreadState的对象，为什么是说当前线程？我们来看看currentPostingThreadState的实现：

```Java
private final ThreadLocal<PostingThreadState> currentPostingThreadState = new ThreadLocal<PostingThreadState>() {
	@Override
	protected PostingThreadState initialValue() {
		return new PostingThreadState();
	}
};
```
currentPostingThreadState的实现是一个包含了PostingThreadState的ThreadLocal对象。

ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储线程，而这段数据是不会与其他线程共享的，其内部原理是通过生成一个它包裹的泛型对象的数组，在不同的线程会有不同的数组索引值，这样就可以做到每个线程通过get()方法获取的时候，取到的只能是自己线程所对应的数据，所以这里取到的就是每个线程的PostingThreadState状态。

接下来我们来看postingSingleEvent()方法：

```Java
private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
	Class<?> eventClass = event.getClass();
	boolean subscriptionFound = false;
	//是否触发订阅了该事件（eventClass）的父类，以及接口的类的响应方法
	if (eventInheritance) {
		////查找eventClass类所有的父类以及接口
		List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);
		int countTypes = eventTypes.size();
		//循环postSingleEventForEventType
		for (int h = 0; h < countTypes; h++) {
			Class<?> clazz = eventTypes.get(h);
			subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);
		}
	} else {
	//post单个事件
		subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
	}
	//如果没有发现
	if (!subscriptionFound) {
		if (logNoSubscriberMessages) {
			Log.d(TAG, "No subscribers registered for event " + eventClass);
		}
		
		if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class &&
				eventClass != SubscriberExceptionEvent.class) {
				//发送一个NoSubscriberEvent事件，如果我们需要处理这种状态，接收这个事件就可以了
			post(new NoSubscriberEvent(this, event));
		}
	}
}
```
从上面可知，实际上事件分发是在postSingleEventForEventType()方法里进行的，代码如下

```Java
private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {
	CopyOnWriteArrayList<Subscription> subscriptions;
	//获取订阅了这个事件的Subscription列表.
	synchronized (this) {
		subscriptions = subscriptionsByEventType.get(eventClass);
	}
	if (subscriptions != null && !subscriptions.isEmpty()) {
		for (Subscription subscription : subscriptions) {
			postingState.event = event;
			postingState.subscription = subscription;
			//是否被中断
			boolean aborted = false;
			try {
				//分发给订阅者
				postToSubscription(subscription, event, postingState.isMainThread);
				aborted = postingState.canceled;
			} finally {
				postingState.event = null;
				postingState.subscription = null;
				postingState.canceled = false;
			}
			if (aborted) {
				break;
			}
		}
		return true;
	}
	return false;
}

private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
	switch (subscription.subscriberMethod.threadMode) {
		case POSTING:
			invokeSubscriber(subscription, event);
			break;
		case MAIN:
			if (isMainThread) {
				invokeSubscriber(subscription, event);
			} else {
				mainThreadPoster.enqueue(subscription, event);
			}
			break;
		case BACKGROUND:
			if (isMainThread) {
				backgroundPoster.enqueue(subscription, event);
			} else {
				invokeSubscriber(subscription, event);
			}
			break;
		case ASYNC:
			asyncPoster.enqueue(subscription, event);
			break;
		default:
			throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode);
	}
}
```
首先从subscriptionsByEventType里获得所有订阅了这个事件的Subscription列表，然后在通过postToSubScription()方法来分发事件，在postToSubScription()通过不同的threadMode在不同的线程里invoke()订阅者的方法，ThreadMode共有四类：

-	PostThread：默认的 ThreadMode，表示在执行 Post 操作的线程直接调用订阅者的事件响应方法，不论该线程是否为主线程（UI 线程）。当该线程为主线程时，响应方法中不能有耗时操作，否则有卡主线程的风险。适用场景：对于是否在主线程执行无要求，但若 Post 线程为主线程，不能耗时的操作；

-	MainThread：在主线程中执行响应方法。如果发布线程就是主线程，则直接调用订阅者的事件响应方法，否则通过主线程的 Handler 发送消息在主线程中处理——调用订阅者的事件响应函数。显然，MainThread类的方法也不能有耗时操作，以避免卡主线程。适用场景：必须在主线程执行的操作；

-	BackgroundThread：在后台线程中执行响应方法。如果发布线程不是主线程，则直接调用订阅者的事件响应函数，否则启动唯一的后台线程去处理。由于后台线程是唯一的，当事件超过一个的时候，它们会被放在队列中依次执行，因此该类响应方法虽然没有PostThread类和MainThread类方法对性能敏感，但最好不要有重度耗时的操作或太频繁的轻度耗时操作，以造成其他操作等待。适用场景：操作轻微耗时且不会过于频繁，即一般的耗时操作都可以放在这里；

-	Async：不论发布线程是否为主线程，都使用一个空闲线程来处理。和BackgroundThread不同的是，Async类的所有线程是相互独立的，因此不会出现卡线程的问题。适用场景：长耗时操作，例如网络访问。

下面我们来看看invokeSubscriber(subscription, event)是如何实现的，关于不同线程的Poster使用可以参考这篇文章[http://kymjs.com/code/2015/12/12/01](http://kymjs.com/code/2015/12/12/01)

invokeSubscriber(subscription, event)代码如下

```Java
void invokeSubscriber(Subscription subscription, Object event) {
	try {
		subscription.subscriberMethod.method.invoke(subscription.subscriber, event);
	} catch (InvocationTargetException e) {
		handleSubscriberException(subscription, event, e.getCause());
	} catch (IllegalAccessException e) {
		throw new IllegalStateException("Unexpected exception", e);
	}
}
```
实际上就是通过反射调用了订阅者的订阅函数并把event对象作为参数传入，至此post()流程如上述所示。整体流程图如下：

![Post流程](http://7xs7a3.com1.z0.glb.clouddn.com/eventbus-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B.png)

## 解除注册过程

解除注册只要调用unregister()方法即可，实现如下：

```Java
public synchronized void unregister(Object subscriber) {
	//通过typesBySubscriber来取出这个subscriber订阅者订阅的事件类型,
	List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);
	if (subscribedTypes != null) {
		//分别解除每个订阅了的事件类型
		for (Class<?> eventType : subscribedTypes) {
			unsubscribeByEventType(subscriber, eventType);
		}
		//从typesBySubscriber移除subscriber
		typesBySubscriber.remove(subscriber);
	} else {
		Log.w(TAG, "Subscriber to unregister was not registered before: " + subscriber.getClass());
	}
}

private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {
	//subscriptionsByEventType里拿出这个事件类型的订阅者列表.
	List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);
	if (subscriptions != null) {
		int size = subscriptions.size();
		//取消订阅
		for (int i = 0; i < size; i++) {
			Subscription subscription = subscriptions.get(i);
			if (subscription.subscriber == subscriber) {
				subscription.active = false;
				subscriptions.remove(i);
				i--;
				size--;
			}
		}
	}
}
```
最终分别从typesBySubscriber和subscriptions里分别移除订阅者以及相关信息即可

# 设计模式

## 观察者模式

观察者模式是对象的行为模式，又叫发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者模式。观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。EventBus并不是标准的观察者模式的实现，但是它的整体就是一个发布/订阅框架，也拥有观察者模式的有点，比如：发布者和订阅者的解耦。


参考文章:

[EventBus 3.0 源码分析](http://www.jianshu.com/p/f057c460c77e)
[EventBus源码研读](http://kymjs.com/code/2015/12/12/01)
[EventBus 源码解析](http://a.codekk.com/detail/Android/Trinea/EventBus%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90)